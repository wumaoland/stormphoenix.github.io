<!DOCTYPE html>
<html>
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <title>GAMES202 Real-Time Shadow Mapping | StormPhoenix</title>
    <meta name="author" content="StormPhoenix">
    <meta name="renderer" content="webkit">
    <meta name="description" content="StormPhoenix's Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" title="Recent Entries" href="">
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
  <script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>

    <body class="body-post">
  <div class="post-wrapper">
    <h1 class="post-title"><a href="/GAMES202_Lecture_03" title="GAMES202 Real-Time Shadow Mapping">GAMES202 Real-Time Shadow Mapping</a></h1>
    <p class="post-date">2021-09-20</p>

    
<script src="/js/mermaid.min.js"></script>

<!--
<script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']]
    }
  };
  </script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
  </script>
-->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
<!-- <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> -->
<script src="/js/MathJax_latest.js" type="text/javascript"></script> 

<!--
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
-->

<!-- <script src="/js/MathJax.js" type="text/javascript"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
      inlineMath: [['$','$']]
    }
  });
</script>
-->

    <h3 id="real-time-shadow-mapping">Real-Time Shadow Mapping</h3>

<p>一种在实时渲染中生成阴影的算法，后文用 SM 代替 Shadow Mapping</p>

<h3 id="sm-有什么用">SM 有什么用</h3>

<p>用来在实时渲染中生成阴影。</p>

<p>对比离线渲染，离线渲染是没有单独考虑如何生成阴影的。因为场景中点 p 的光照强弱是由四面八方的 Radiance 决定的（按照渲染方程计算）。首先光线的传播、光强损失是遵循物理的，p 点如果被遮挡的多，那么传播到 p 点的光线就少、光强就弱，反之光线就多，光强就强。所以理论上 p 点计算的光强就应该和实际情况一致，不需要把阴影作为一个特殊的 case 考虑。</p>

<p>还是前文提到过的，实时渲染需要的是性能，要在极短的事件内计算出结果，采用光线追踪肯定是不可行的。如果能够知道场景中物体的空间结构以及光源位置，那么阴影覆盖区域是可以提前计算的。</p>

<p>所以 SM 的思路就是：先计算场景“遮挡关系”，后续渲染流程就根据计算好的“遮挡关系”来判断某一点 p 是否被遮挡，如果遮挡就认为 p 点处有阴影。</p>

<h3 id="shadow-mapping">Shadow Mapping</h3>

<p>RTR 中有一个可以用来表示场景 “遮挡关系” 的东西 - 相机拍摄的深度信息。而在 OpenGL 渲染管线中有一个可以用来存储深度信息的技术 - <a href="https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/05%20Framebuffers/">帧缓冲</a>，帧缓冲具体是什么可以在学习 OpenGL 时了解，这里只需要知道它是用来存储场景到相机的深度信息。</p>

<p><img src="/images/RTR/Render_from_Light.jpeg" alt="Render from Light" height="70%" width="70%"></p>

<p>深度信息图示：
<img src="/images/RTR/Depth_Texture.jpg" alt="Depth texture" height="70%" width="70%"></p>

<p>我们考虑场景里有一个点光源，假设在点光源处放置一个相机去拍摄整个场景，得到这个相机视角下场景的深度信息。这块深度信息将被存储到一块 depth texture 纹理里面，供算法后续使用。至此，SM 算法第一阶段完成（称之为第一个 Pass）。</p>

<p><img src="/images/RTR/Render_from_Eye.jpeg" alt="Render from Eye" height="70%" width="70%"></p>

<p>将相机转移至 eye 处进行拍摄渲染，为了方便称呼，我们把场景中每个需要渲染的点称之为 shading point。</p>

<p>此时可以得到两个信息：一幅没有阴影的渲染图像、从上个 pass 传递过来的 depth texture。我们知道 depth texture 保存的是光源视角下拍摄的深度信息，为了在相机视角下确定某个位置是否被遮挡，只需将 shading point 到光源的深度和 depth texture 记录的深度进行比较，如果比记录的深度大，说明该 shading point 被遮挡。</p>

<p><img src="/images/RTR/SM_Results.jpeg" alt="Shadow Mapping Results" height="70%" width="70%"></p>

<h3 id="sm-存在的问题">SM 存在的问题</h3>

<p>SM 算法实际应用下至少会有三个问题：</p>

<ul>
  <li>锯齿状阴影</li>
  <li>自遮挡现象</li>
  <li>只能渲染硬阴影</li>
</ul>

<h4 id="锯齿状阴影">锯齿状阴影</h4>

<p>阴影边缘出现锯齿状的原因在于 SM 的分辨率。</p>

<p><img src="/images/RTR/Shadow_Map_Antianliasing.jpg" alt="Shadow Map Antialiasing" height="70%" width="70%"></p>

<p><a href="https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch11.html">Shadow Map Antialiasing</a></p>

<p>理想情况下，SM 的深度图中，每个像素记录的应该是场景中每个点的深度，但 depth texture 存在分辨率的限制，所以实际上每个像素代表的不是场景中一个 “<strong>点</strong>”，而是一块 “<strong>区域</strong>”。</p>

<p><img src="/images/RTR/SM_Resolution.jpeg" alt="SM Resolution" height="70%" width="70%"></p>

<p>如上图，因为 shadow map 分辨率的原因，反投影回地面区域的深度信息是离散、不连续的。一些不应该被遮挡的部分被 SM 判定为遮挡，展现出来就是阴影边缘的锯齿。一种解决办法是 PCF，在 shadow map 上做多次采样深度并加权，后文会提到。</p>

<h4 id="自遮挡现象self-occlusion">自遮挡现象（Self occlusion）</h4>

<p>自遮挡现象是指一些没有被遮挡的部位也出现了被遮挡现象。</p>

<p><img src="/images/RTR/Self_occlusion.jpg" alt="Self occlusion" height="40%" width="40%"></p>

<p>这张图渲染错误的地方是地板上出现的花纹状阴影。本质上和锯齿状阴影一样，是由 Shadow map 的分辨率不足引起的。</p>

<p>Shadow map 上记录的深度是离散、不连续的，不能代表场景中任意位置的真实深度。因此从 Shadow map 采样得到的深度可能要比真实深度或大或小，之后的比较的结果会出错，让一些本来没有被遮挡的区域看起来被遮挡了。</p>

<p><img src="/images/RTR/Self_occlusion2.jpeg" alt="Self occlusion 2" width="70%"></p>

<p>容易想到的解决方法：做深度判定的时候增加一个 bias 项，shadow map 记录的深度如果落在 bias 区间内则认为不存在遮挡。</p>

<p><img src="/images/RTR/Self_occlusion_bias.jpeg" alt="Self occlusion bias" width="70%"></p>

<p>这个方法引入了一个新问题：模型悬空。bias 是人为选取，那么选取多大的 bias 才是合适？bias 选取过大会让本应存在的遮挡关系被忽略，让物体看起来像是悬空。</p>

<p><img src="/images/RTR/Self_occlusion_bias_detach.jpg" alt="Self_occlusion_bias_detach" width="40%"></p>

<p>目前还没有更好的方法确定 bias 区间大小。工业界可能有一些动态更新 bias 大小的方法，但我还不太了解。</p>

<h4 id="只能渲染硬阴影">只能渲染硬阴影</h4>

<p>以上的 SM 模型是以点光源来构建的，阴影会有明显的边界。实际中大部分光源是面光源，阴影边界处会有明显的明暗过渡，如下：</p>

<p><img src="/images/RTR/Soft_shadow.jpg" alt="Soft shadow" width="70%"></p>

<p>直接将 SM 中的点光源模型替换成面光源是不可行的。因为拍摄 Shadow map 的相机可以摆放到点光源位置，如果是面光源，那相机应该摆放在何处？</p>

<p>有一种解决办法也是利用 PCF。首先假设，如果 p 点被遮挡，那么深度比较结果为 1，反之为 0。现在依然以点光源为模型生成 Shadow map，不在处理阴影的时候多次采样深度比较，结果做加权，最终 p 点得到的结果将会介于 [0, 1] 之间，用这个结果来表示阴影软硬程度，后文将具体介绍。</p>

<p><img src="/images/RTR/Conclusion.jpeg" alt="Conclusion" width="70%"></p>

<div class="mermaid">
pie title Pets adopted by volunteers
"Dogs" : 386
"Cats" : 85
"Rats" : 35
</div>

<div class="mermaid">
graph LR
A[hard edge] --&gt;B(Round edge)
</div>

<div class="mermaid">
graph TD;
    A--&gt;B;
    A--&gt;C;
    B--&gt;D;
    C--&gt;D;
</div>

<h3 id="shadow-mapping-后的数学原理">Shadow Mapping 后的数学原理</h3>

<p>课程引入了一个重要的不等式：</p>

<p>$$ \int_{\Omega} f(x)g(x)dx \approx \frac{\int_{\Omega} f(x)dx}{\int_{\Omega}dx} \cdot \int_{\Omega} g(x) dx $$</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 成立条件：
 (1) g(x) 的 support（积分范围）足够小。
 (2) g(x) 足够 smooth（平滑）。
</code></pre></div></div>

<p>引入这个公式的目的是为了说明：在实时渲染领域，任何 “近似相等” 都等价于 “相等”。将这个约等式应用于渲染方程，将方程内的 Visibility 项提到公式外部，如下：</p>

<p>$$ L_o(p, \omega_o) = \int_{\Omega_{+}} L_i(p, \omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_{i}V(p, \omega_i)d \omega_{i} $$</p>

<p>Visibibity 项提取到外部</p>

<p>$$ L_o(p, \omega_o) \approx \frac{\int_{\Omega+}V(p, \omega_i)d\omega_i}{\int_{\Omega+}d\omega_i} \int_{\Omega+}L_i(p, \omega_i) f_r(p, \omega_i, \omega_o) \cos \theta_i d\omega_i $$</p>

<p>重新审视一下公式成立条件，看这个近似能不能成立。首先是</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (1) g(x) 的 support（积分范围）足够小。
</code></pre></div></div>

<p>这要求公式左边的 Li 的积分范围足够小，对应到实际环境是要求光源必须是点光源。点光源相当于是空间中的一个点，体积很小，从 p 点看向光源的立体角 wi 也相对小。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (2) g(x) 必须是 smooth 的
</code></pre></div></div>

<p>这要求公示左边的 Li 和 BRDF 足够光滑。Li 足够光滑的情况是环境光、面光源，BRDF 必须是接近 diffuse 的。</p>

<p>这么看来近似式成立的条件都可以在 RTR 中找到对应的场景，那么公式如此变换的物理含义是什么？我理解是这样的，把 Visibility 项提到积分号外单独做积分，实际上是计算点 p 的半球空间的阴影比例，也就是 “遮挡率”。公式最右边的积分可以不考虑 visibility 先计算出 shading 值，最后乘以 “遮挡率” 得到最终 shading 结果。</p>

<p>如果 “遮挡率” 计算的值为 0，那么 shading point 被完全遮挡；为 1 说明 shading point 没有被遮挡；处于 (0, 1) 之间说明 p 点被部分遮挡，计算结果半明半暗，也就对应到 SM 中的软阴影部位。</p>

<p>总结：在点光源、亮度平滑的面光源或 BRDF 足够平滑的情况下，shading 值可以通过独立计算 “遮挡率” 来表示明暗程度。那么接下来如何 “遮挡率” ？对 shading point 的半球面做积分太耗费时间，必定不可行。可能的方法只能在采样算法里面找，这就引出接下来的办法：PCF。</p>

<h3 id="percentage-closer-filter-pcf">Percentage Closer Filter (PCF)</h3>

<p>PCF：SM 做深度测试不仅仅只采样当前深度，还会采样周围深度值。</p>

<h3 id="percentage-closer-soft-shadows-pcss">Percentage Closer Soft Shadows (PCSS)</h3>



    <div id="disqus_container">
  <div class="share-con">
    <script type="text/javascript" charset="utf-8">
      (function(){
        var param = {
          url: 'http://stormphoenix.github.io/GAMES202_Lecture_03',
          type: '6',
          title: '《GAMES202 Real-Time Shadow Mapping》' + '- 高质量实时渲染 Lecture 03 - Real-Time Shadow Mapping',
          ralateUid: '6425419082',
          rnd:new Date().valueOf()
        }
        var temp = [];
        for( var p in param ){
          temp.push(p + '=' + encodeURIComponent( param[p] || '' ) )
        }
        document.write('<iframe allowTransparency="true" frameborder="0" scrolling="no" src="http://hits.sinajs.cn/A1/weiboshare.html?' + temp.join('&') + '" width="86" height="16"></iframe>')
      })()
    </script>
  </div>

  <a href="#" class="comment" onclick="return false;">点击查看评论</a>
  <div id="disqus_thread"></div>
</div>


  </div>

  <div class="about-wrapper">
	<!--  <iframe width="100%" height="75" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=75&fansRow=2&ptype=1&speed=0&skin=5&isTitle=0&noborder=0&isWeibo=0&isFans=0&uid=1855270953&verifier=375b89d6&dpc=1" style="margin: 30px 0;"></iframe> -->

  <div class="aboutme">
    <h2><a href="/">所有文章</a></h2>
    <ul>
      
      <li>
        <a href="/GAMES202_Lecture_03" class="title">GAMES202 Real-Time Shadow Mapping</a>
      </li>
      
      <li>
        <a href="/GAMES202_Lecture_02" class="title">GAMES202 CG Basics</a>
      </li>
      
      <li>
        <a href="/GAMES202_Lecture_01" class="title">GAMES202 Introduction and Overview</a>
      </li>
      
      <li>
        <a href="/anatomy-of-linux-kernel-2" class="title">Linux内核完全剖析（二）</a>
      </li>
      
      <li>
        <a href="/Spring-series-four" class="title">Spring系列（四）</a>
      </li>
      
      <li>
        <a href="/Spring-series-three" class="title">Spring系列（三）</a>
      </li>
      
      <li>
        <a href="/anatomy-of-linux-kernel-1" class="title">Linux内核完全剖析（一）</a>
      </li>
      
      <li>
        <a href="/Spring-series-two" class="title">Spring系列（二）</a>
      </li>
      
      <li>
        <a href="/Spring-series-one" class="title">Spring系列（一）</a>
      </li>
      
      <li>
        <a href="/use-quota" class="title">使用Quota</a>
      </li>
      
      <li>
        <a href="/Linux%E8%B4%A6%E5%8F%B7%E7%AE%A1%E7%90%86" class="title">Linux账号管理</a>
      </li>
      
      <li>
        <a href="/Linux%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C" class="title">Linux文件操作</a>
      </li>
      
      <li>
        <a href="/use-ACL" class="title">ACL的使用</a>
      </li>
      
      <li>
        <a href="/carriage-return-line-feed-new-line-end-file" class="title">回车、换行、和文件末尾空行</a>
      </li>
      
    </ul>
  </div>
</div>


  <script src="/js/jquery-1.7.1.min.js" type="text/javascript"></script>
  <script src="/js/post.js" type="text/javascript"></script>
</body>


</html>
