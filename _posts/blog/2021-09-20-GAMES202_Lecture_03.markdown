---
layout: post
title:    "GAMES202 Real-Time Shadow Mapping"
date:    2021-09-20 12:25:50 +0800
categories:    blog
description: 高质量实时渲染 Lecture 03 - Real-Time Shadow Mapping
comments: true
---

### Real-Time Shadow Mapping

一种在实时渲染中生成阴影的算法，后文用 SM 代替 Shadow Mapping

### SM 有什么用

用来在实时渲染中生成阴影。

对比离线渲染，离线渲染是没有单独考虑如何生成阴影的。因为场景中点 p 的光照强弱是由四面八方的 Radiance 决定的（按照渲染方程计算）。首先光线的传播、光强损失是遵循物理的，p 点如果被遮挡的多，那么传播到 p 点的光线就少、光强就弱，反之光线就多，光强就强。所以理论上 p 点计算的光强就应该和实际情况一致，不需要把阴影作为一个特殊的 case 考虑。

还是前文提到过的，实时渲染需要的是性能，要在极短的事件内计算出结果，采用光线追踪肯定是不可行的。如果能够知道场景中物体的空间结构以及光源位置，那么阴影覆盖区域是可以提前计算的。

所以 SM 的思路就是：先计算场景“遮挡关系”，后续渲染流程就根据计算好的“遮挡关系”来判断某一点 p 是否被遮挡，如果遮挡就认为 p 点处有阴影。

### Shadow Mapping

RTR 中有一个可以用来表示场景 “遮挡关系” 的东西 - 相机拍摄的深度信息。而在 OpenGL 渲染管线中有一个可以用来存储深度信息的技术 - [帧缓冲][link_FrameBuffer]，帧缓冲具体是什么可以在学习 OpenGL 时了解，这里只需要知道它是用来存储场景到相机的深度信息。

![Render from Light](/images/RTR/Render_from_Light.jpeg){:height="70%" width="70%"}

深度信息图示：
![Depth texture](/images/RTR/Depth_Texture.jpg){:height="70%" width="70%"}

我们考虑场景里有一个点光源，假设在点光源处放置一个相机去拍摄整个场景，得到这个相机视角下场景的深度信息。这块深度信息将被存储到一块 depth texture 纹理里面，供算法后续使用。至此，SM 算法第一阶段完成（称之为第一个 Pass）。

![Render from Eye](/images/RTR/Render_from_Eye.jpeg){:height="70%" width="70%"}

将相机转移至 eye 处进行拍摄渲染，为了方便称呼，我们把场景中每个需要渲染的点称之为 shading point。

此时可以得到两个信息：一幅没有阴影的渲染图像、从上个 pass 传递过来的 depth texture。我们知道 depth texture 保存的是光源视角下拍摄的深度信息，为了在相机视角下确定某个位置是否被遮挡，只需将 shading point 到光源的深度和 depth texture 记录的深度进行比较，如果比记录的深度大，说明该 shading point 被遮挡。

![Shadow Mapping Results](/images/RTR/SM_Results.jpeg){:height="70%" width="70%"}

### SM 存在的问题

SM 算法实际应用下至少会有三个问题：

- 锯齿状阴影
- 自遮挡现象
- 只能渲染硬阴影

#### 锯齿状阴影

阴影边缘出现锯齿状的原因在于 SM 的分辨率。

![Shadow Map Antialiasing](/images/RTR/Shadow_Map_Antianliasing.jpg){:height="70%" width="70%"}

[Shadow Map Antialiasing][link_Antialiasing]

理想情况下，SM 的深度图中，每个像素记录的应该是场景中每个点的深度，但 depth texture 存在分辨率的限制，所以实际上每个像素代表的不是场景中一个 “**点**”，而是一块 “**区域**”。

![SM Resolution](/images/RTR/SM_Resolution.jpeg){:height="70%" width="70%"}

如上图，因为 shadow map 分辨率的原因，反投影回地面区域的深度信息是离散、不连续的。一些不应该被遮挡的部分被 SM 判定为遮挡，展现出来就是阴影边缘的锯齿。一种解决办法是 PCF，在 shadow map 上做多次采样深度并加权，后文会提到。

#### 自遮挡现象（Self occlusion）

自遮挡现象是指一些没有被遮挡的部位也出现了被遮挡现象。

![Self occlusion](/images/RTR/Self_occlusion.jpg){:height="40%" width="40%"}

这张图渲染错误的地方是地板上出现的花纹状阴影。本质上和锯齿状阴影一样，是由 Shadow map 的分辨率不足引起的。

Shadow map 上记录的深度是离散、不连续的，不能代表场景中任意位置的真实深度。因此从 Shadow map 采样得到的深度可能要比真实深度或大或小，之后的比较的结果会出错，让一些本来没有被遮挡的区域看起来被遮挡了。

![Self occlusion 2](/images/RTR/Self_occlusion2.jpeg){:width="70%"}

容易想到的解决方法：做深度判定的时候增加一个 bias 项，shadow map 记录的深度如果落在 bias 区间内则认为不存在遮挡。

![Self occlusion bias](/images/RTR/Self_occlusion_bias.jpeg){:width="70%"}

这个方法引入了一个新问题：模型悬空。bias 是人为选取，那么选取多大的 bias 才是合适？bias 选取过大会让本应存在的遮挡关系被忽略，让物体看起来像是悬空。

![Self_occlusion_bias_detach](/images/RTR/Self_occlusion_bias_detach.jpg){:width="40%"}

目前还没有更好的方法确定 bias 区间大小。工业界可能有一些动态更新 bias 大小的方法，但我还不太了解。

#### 只能渲染硬阴影

以上的 SM 模型是以点光源来构建的，阴影会有明显的边界。实际中大部分光源是面光源，阴影边界处会有明显的明暗过渡，如下：

![Soft shadow](/images/RTR/Soft_shadow.jpg){:width="70%"}

直接将 SM 中的点光源模型替换成面光源是不可行的。因为拍摄 Shadow map 的相机可以摆放到点光源位置，如果是面光源，那相机应该摆放在何处？

有一种解决办法也是利用 PCF。首先假设，如果 p 点被遮挡，那么深度比较结果为 1，反之为 0。现在依然以点光源为模型生成 Shadow map，不在处理阴影的时候多次采样深度比较，结果做加权，最终 p 点得到的结果将会介于 [0, 1] 之间，用这个结果来表示阴影软硬程度，后文将具体介绍。

![Conclusion](/images/RTR/Conclusion.jpeg){:width="70%"}


<div class="mermaid">
pie title Pets adopted by volunteers
"Dogs" : 386
"Cats" : 85
"Rats" : 35
</div>

<div class="mermaid">
graph LR
A[hard edge] -->B(Round edge)
</div>

<div class="mermaid">
graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;
</div>

### Shadow Mapping 后的数学原理

课程引入了一个重要的不等式：

$$ \int_{\Omega} f(x)g(x)dx \approx \frac{\int_{\Omega} f(x)dx}{\int_{\Omega}dx} \cdot \int_{\Omega} g(x) dx $$


 成立条件：

```
 (1) g(x) 的 support（积分范围）足够小。
 (2) g(x) 足够 smooth（平滑）。
```

引入这个公式的目的是为了说明：在实时渲染领域，任何 “近似相等” 都等价于 “相等”。将这个约等式应用于渲染方程，将方程内的 Visibility 项提到公式外部，如下：

$$ L_o(p, \omega_o) = \int_{\Omega_{+}} L_i(p, \omega_i)f_r(p,\omega_i,\omega_o)\cos\theta_{i}V(p, \omega_i)d \omega_{i} $$

Visibibity 项提取到外部

$$ L_o(p, \omega_o) \approx \frac{\int_{\Omega+}V(p, \omega_i)d\omega_i}{\int_{\Omega+}d\omega_i} \int_{\Omega+}L_i(p, \omega_i) f_r(p, \omega_i, \omega_o) \cos \theta_i d\omega_i $$

重新审视一下公式成立条件，看这个近似能不能成立。首先是 

```
 (1) g(x) 的 support（积分范围）足够小。
```

这要求公式左边的 Li 的积分范围足够小，对应到实际环境是要求光源必须是点光源。点光源相当于是空间中的一个点，体积很小，从 p 点看向光源的立体角 wi 也相对小。

```
 (2) g(x) 必须是 smooth 的
```

这要求公示左边的 Li 和 BRDF 足够光滑。Li 足够光滑的情况是环境光、面光源，BRDF 必须是接近 diffuse 的。

这么看来近似式成立的条件都可以在 RTR 中找到对应的场景，那么公式如此变换的物理含义是什么？我理解是这样的，把 Visibility 项提到积分号外单独做积分，实际上是计算点 p 的半球空间的阴影比例，也就是 “遮挡率”。公式最右边的积分可以不考虑 visibility 先计算出 shading 值，最后乘以 “遮挡率” 得到最终 shading 结果。

如果 “遮挡率” 计算的值为 0，那么 shading point 被完全遮挡；为 1 说明 shading point 没有被遮挡；处于 (0, 1) 之间说明 p 点被部分遮挡，计算结果半明半暗，也就对应到 SM 中的软阴影部位。

总结：在点光源、亮度平滑的面光源或 BRDF 足够平滑的情况下，shading 值可以通过独立计算 “遮挡率” 来表示明暗程度。那么接下来如何 “遮挡率” ？对 shading point 的半球面做积分太耗费时间，必定不可行。可能的方法只能在采样算法里面找，这就引出接下来的办法：PCF。

### Percentage Closer Filter (PCF)

PCF：SM 做深度测试不仅仅只采样当前深度，还会采样周围深度值。

### Percentage Closer Soft Shadows (PCSS)

[link_FrameBuffer]: https://learnopengl-cn.github.io/04%20Advanced%20OpenGL/05%20Framebuffers/

[link_Antialiasing]: https://developer.download.nvidia.com/books/HTML/gpugems/gpugems_ch11.html
